<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LeetCode Stack Cheat Sheet</title>
    <style>
        @page { size: A4; margin: 0.3cm 0.3cm 0.3cm 0.3cm; }
        body {
            font-family: "Arial", sans-serif;
            font-size: 7pt;
            line-height: 1.2;
            color: #000;
            background: #fff;
        margin: 0;
            padding: 0;
        }
        .container {
            column-count: 3;
            column-gap: 0.25cm;
            width: 100%;
        }
        .box {
            border: 1px solid #444;
            padding: 2px 4px;
            margin-bottom: 4px;
            break-inside: avoid;
            background-color: #fff;
        }
        h2 {
            font-size: 8pt;
            font-weight: bold;
            background-color: #eee;
            padding: 2px;
            margin: 0 0 2px 0;
            border-bottom: 1px solid #000;
            text-transform: uppercase;
        }
        h3 {
            font-size: 7.5pt;
            font-weight: bold;
            margin: 2px 0 1px 0;
            text-decoration: underline;
            color: #004085;
        }
        p { margin: 0 0 2px 0; text-align: left; }
        ul { padding-left: 10px; margin: 0; }
        li { margin: 0; }
        .code-box {
            font-family: "Courier New", monospace;
            background-color: #f4f4f4;
            border-left: 2px solid #333;
            padding: 1px 2px;
            margin: 1px 0;
            font-size: 6.5pt;
            white-space: pre-wrap;
        }
        .tag {
            font-weight: bold;
            color: #d63384;
            font-size: 6.5pt;
        }
        .complexity {
            font-weight: bold;
            font-size: 6.5pt;
            color: #007bff;
            float: right;
        }
        .warn { color: #b00; font-weight: bold; }
        .intro-box {
            background-color: #fff3cd;
            border: 2px solid #856404;
            padding: 4px;
            margin-bottom: 6px;
            break-inside: avoid;
        }
    </style>
</head>
<body>

<div class="container">

    <!-- Introduction -->
    <div class="intro-box">
        <h2>When to Use a Stack?</h2>
        <p><b>Core Idea:</b> LIFO (Last-In-First-Out). Process elements where the <b>most recent</b> item matters, or where a <b>future element</b> resolves something about a <b>past element</b>.</p>
        <h3>Pattern Recognition:</h3>
        <ul>
            <li><b>Matching/Nesting:</b> Parentheses, tags, nested structures - most recent open must close first</li>
            <li><b>Next Greater/Smaller:</b> "Find next warmer day", "next smaller element" - future resolves past</li>
            <li><b>Expression Evaluation:</b> RPN, calculators - operators act on most recent operands</li>
            <li><b>Undo/History:</b> Most recent action reversed first</li>
            <li><b>Monotonic Problems:</b> Maintain increasing/decreasing order to find boundaries</li>
        </ul>
        <h3>Key Insight:</h3>
        <p><b>Past Depends on Future:</b> When you can't resolve an element until you see a future element, push it to stack. When you find the "answer" for stack elements, pop and process them.</p>
        <p><b>Why Not Just Array?</b> Stack enforces the "most recent first" discipline. When processing, you only care about the top - O(1) access to the relevant element.</p>
    </div>

    <!-- 1. Valid Parentheses -->
    <div class="box">
        <h2>Valid Parentheses</h2>
        <span class="complexity">O(n) Time / O(n) Space</span>
        <p><b>Goal:</b> Check if brackets are properly matched and nested.</p>
        <h3>Technique: Matching Stack</h3>
        <p><b>Why Stack?</b> Innermost bracket must close first. When we see ')', we need the most recent '(' - that's exactly what stack top gives us. LIFO matches nesting structure perfectly.</p>
        <p><b>Key Insight:</b> Push opening brackets. When closing bracket arrives, stack top must be matching opener. If not, or stack empty, invalid.</p>
        <div class="code-box">endPair := map[string]string{")":"(", "}":"{", "]":"["}
var stack []string
for _, c := range s:
  if match, ok := endPair[c]; ok:
    if len(stack)==0 || stack[top] != match:
      return false
    stack = stack[:len(stack)-1]  // pop
  else:
    stack = append(stack, c)  // push opener
return len(stack) == 0</div>
        <p class="warn">Don't Forget:</p> Check stack is empty at end - unmatched openers are invalid.
    </div>

    <!-- 2. Min Stack -->
    <div class="box">
        <h2>Min Stack</h2>
        <span class="complexity">O(1) All Operations</span>
        <p><b>Goal:</b> Stack with O(1) push, pop, top, AND getMin.</p>
        <h3>Technique: Auxiliary Monotonic Stack</h3>
        <p><b>Why Two Stacks?</b> Main stack for values. Monotonic decreasing stack for minimums. When we push a new minimum, it goes on both. When we pop, if it equals mono top, pop both.</p>
        <p><b>Key Insight:</b> Larger values pushed after a minimum will be popped before that minimum. So we don't need to track them in mono stack - they can never be the min while the smaller value exists.</p>
        <div class="code-box">type MinStack struct {
  stack     []int
  monoStack []int  // decreasing: tracks minimums
}
func (s *MinStack) Push(val int):
  if len(monoStack)==0 || monoStack[top] >= val:
    monoStack = append(monoStack, val)
  stack = append(stack, val)
func (s *MinStack) Pop():
  popped := stack[top]; stack = stack[:len-1]
  if popped == monoStack[top]:
    monoStack = monoStack[:len-1]
func (s *MinStack) GetMin(): return monoStack[top]</div>
        <p class="tag">Mono Stack Insight:</p> Only track values that could be min at some point.
    </div>

    <!-- 3. Evaluate Reverse Polish Notation -->
    <div class="box">
        <h2>Evaluate Reverse Polish Notation</h2>
        <span class="complexity">O(n) Time / O(n) Space</span>
        <p><b>Goal:</b> Evaluate postfix expression like ["2","1","+","3","*"] = 9.</p>
        <h3>Technique: Operand Stack</h3>
        <p><b>Why Stack?</b> In RPN, operators act on the two most recent operands. Stack naturally accumulates operands, and operator pops exactly what it needs. Result becomes new operand.</p>
        <p><b>Key Insight:</b> Numbers → push. Operator → pop two, compute, push result. Final answer is last item on stack.</p>
        <div class="code-box">var stack []int
for _, token := range tokens:
  switch token:
  case "+", "-", "*", "/":
    b := stack[len-1]; stack = stack[:len-1]
    a := stack[len-1]; stack = stack[:len-1]
    switch token:
      case "+": stack = append(stack, a+b)
      case "-": stack = append(stack, a-b)
      case "*": stack = append(stack, a*b)
      case "/": stack = append(stack, a/b)
  default:
    val, _ := strconv.Atoi(token)
    stack = append(stack, val)
return stack[0]</div>
        <p class="warn">Order Matters:</p> For - and /, it's a op b where a is deeper in stack (second-to-top).
    </div>

    <!-- 4. Daily Temperatures -->
    <div class="box">
        <h2>Daily Temperatures</h2>
        <span class="complexity">O(n) Time / O(n) Space</span>
        <p><b>Goal:</b> For each day, find days until a warmer temperature.</p>
        <h3>Technique: Monotonic Decreasing Stack</h3>
        <p><b>Why Stack?</b> Classic "next greater element" pattern. We can't answer "when is next warmer day?" until we see that warmer day. Push indices to stack; when warmer day arrives, it resolves all cooler days waiting on stack.</p>
        <p><b>Key Insight:</b> Stack holds indices of days "waiting for answer". When temp[i] > temp[stack.top], we found the answer for stack.top. Pop and record distance. Stack stays monotonic decreasing (in temperature).</p>
        <div class="code-box">res := make([]int, len(temps))
var stack []int  // indices, mono decreasing by temp
for i := 0; i < len(temps); i++:
  // Current temp resolves all smaller temps on stack
  for len(stack) > 0 && temps[stack[top]] < temps[i]:
    idx := stack[top]
    stack = stack[:len-1]
    res[idx] = i - idx  // days until warmer
  stack = append(stack, i)
return res  // unresolved days stay 0</div>
        <p class="tag">Next Greater Element:</p> Mono decreasing stack. Pop when you find something greater.
    </div>

    <!-- 5. Car Fleet -->
    <div class="box">
        <h2>Car Fleet</h2>
        <span class="complexity">O(n log n) Time / O(n) Space</span>
        <p><b>Goal:</b> Count how many car fleets arrive at destination.</p>
        <h3>Technique: Time-to-Target Comparison</h3>
        <p><b>Why Stack-like?</b> Sort by position (closest to target first). For each car, calculate time to reach target. If a car behind takes LESS time, it would catch up and merge (same fleet). If MORE time, separate fleet.</p>
        <p><b>Key Insight:</b> Process from closest to target. Stack tracks fleet arrival times. If current car's time ≤ stack top, it merges (catches up). If time > stack top, it's a new fleet - push it.</p>
        <div class="code-box">// Sort by position descending (closest to target first)
sort cars by position DESC
var stack []float64  // arrival times of fleets
for each car:
  time := (target - car.pos) / car.speed
  if len(stack)==0 || time > stack[top]:
    stack = append(stack, time)  // new fleet
  // else: merges with fleet ahead (time <= stack top)
return len(stack)</div>
        <p class="warn">Key Formula:</p> time_to_target = (target - position) / speed. Compare times, not positions.
    </div>

    <!-- 6. Largest Rectangle in Histogram -->
    <div class="box">
        <h2>Largest Rectangle in Histogram</h2>
        <span class="complexity">O(n) Time / O(n) Space</span>
        <p><b>Goal:</b> Find largest rectangle area in histogram bars.</p>
        <h3>Technique: Monotonic Increasing Stack</h3>
        <p><b>Why Stack?</b> For each bar, we need its left and right boundaries (next smaller elements). When we see a shorter bar, it's the right boundary for all taller bars on stack. The bar below in stack is the left boundary.</p>
        <p><b>Key Insight:</b> Stack holds indices in increasing height order. When heights[i] < stack top, we found right boundary for top. Pop, calculate area using: height × (rightBound - leftBound - 1). Left bound is new stack top (or -1 if empty).</p>
        <div class="code-box">var stack []int  // indices, mono increasing by height
maxArea := 0
for i := 0; i <= len(heights); i++:
  // i==len or shorter bar: resolve taller bars
  for len(stack)>0 && (i==len || heights[stack[top]] >= heights[i]):
    h := heights[stack[top]]
    stack = stack[:len-1]
    width := i  // right boundary
    if len(stack) > 0:
      width = i - stack[top] - 1  // between boundaries
    maxArea = max(maxArea, h * width)
  if i < len(heights):
    stack = append(stack, i)
return maxArea</div>
        <p class="tag">Next Smaller Element:</p> Mono increasing stack. Pop when you find something smaller.
    </div>

    <!-- 7. Trapping Rain Water -->
    <div class="box">
        <h2>Trapping Rain Water</h2>
        <span class="complexity">O(n) Time / O(n) Space</span>
        <p><b>Goal:</b> Calculate total water trapped between bars after rain.</p>
        <h3>Technique: Monotonic Decreasing Stack</h3>
        <p><b>Why Stack?</b> Water is trapped between two walls with a lower region between them. We can't know the right wall until we see it. Stack holds bars waiting for a taller bar to appear (their right boundary).</p>
        <p><b>Key Insight:</b> Unlike prefix-max approach (column by column), stack calculates water <b>layer by layer horizontally</b>. Each pop handles one horizontal layer of water between two walls.</p>
        <h3>The Three-Element Boundary Pattern:</h3>
        <p>When we pop from stack, we have access to three critical elements:</p>
        <ul>
            <li><b>Current index i</b> = Right boundary (the taller bar that triggered the pop)</li>
            <li><b>Popped element</b> = Bottom/floor (the element of interest - lowest point)</li>
            <li><b>New stack top</b> = Left boundary (next element after pop)</li>
        </ul>
        <p><b>Why This Works:</b> The monotonic decreasing property guarantees that after popping the bottom, the new top is taller (or equal). Combined with the current bar being taller than bottom, we have a valid "container" with walls on both sides.</p>
        <div class="code-box">var stack []int  // indices, mono decreasing by height
res := 0
for i := 0; i < len(height); i++:
  for len(stack)>0 && height[i] >= height[stack[top]]:
    bottomIdx := stack[top]       // Element of interest
    stack = stack[:len-1]         // Pop bottom
    if len(stack) > 0:            // Need left wall
      leftIdx := stack[top]       // Left boundary
      h := min(height[leftIdx], height[i]) - height[bottomIdx]
      w := i - leftIdx - 1        // Width between walls
      res += h * w
  stack = append(stack, i)
return res</div>
        <h3>Column vs Layer Mental Model:</h3>
        <p><b>Array approach (prefix/suffix):</b> For each column, calculate vertical water height = min(leftMax, rightMax) - height.</p>
        <p><b>Stack approach:</b> Fill water horizontally between two walls, layer by layer from bottom up. Same rightBound triggers multiple pops, each pop adds one layer on top of the previous.</p>
        <h3>Concrete Trace - [5, 2, 1, 3]:</h3>
        <div class="code-box">Stack builds: [5, 2, 1]
When i=3 (rightBound=3) arrives:
  Pop #1: bottom=1, left=2, right=3
    h=min(2,3)-1=1, w=1 → Layer 1 (height 1→2)
  Pop #2: bottom=2, left=5, right=3 (SAME rightBound!)
    h=min(5,3)-2=1, w=2 → Layer 2 (height 2→3)
  Stop: 3 < 5 (rightBound < stack top)</div>
        <p><b>Key:</b> Within one rightBound's pop loop, successive pops add layers vertically. Each pop has a taller leftBound, filling a wider region. Stops when rightBound becomes the limiting wall.</p>
        <p class="tag">Layer-by-Layer:</p> Each pop calculates one horizontal water layer. The same "pool" may generate multiple pops as we fill it layer by layer from bottom up.
        <p class="warn">Must Have Left Wall:</p> After popping bottom, if stack is empty there's no left wall - no water can be trapped. Always check stack not empty before calculating.
    </div>

    <!-- Pattern Summary -->
    <div class="intro-box">
        <h2>Stack Patterns Summary</h2>
        <h3>1. Matching/Nesting:</h3>
        <p><b>Use When:</b> Validating balanced structures (parentheses, tags, nested calls).</p>
        <p><b>Template:</b> Push openers, pop and match on closers.</p>
        <p><b>Example:</b> Valid Parentheses.</p>

        <h3>2. Expression Evaluation:</h3>
        <p><b>Use When:</b> Evaluating RPN, calculators, parsing expressions.</p>
        <p><b>Template:</b> Push operands, pop for operators, push result.</p>
        <p><b>Example:</b> Evaluate RPN.</p>

        <h3>3. Next Greater Element (Mono Decreasing):</h3>
        <p><b>Use When:</b> "Find next larger/warmer/higher element."</p>
        <p><b>Template:</b> Push to stack. When greater found, pop and resolve.</p>
        <p><b>Example:</b> Daily Temperatures.</p>

        <h3>4. Next Smaller Element (Mono Increasing):</h3>
        <p><b>Use When:</b> "Find boundaries", "largest rectangle", "next smaller".</p>
        <p><b>Template:</b> Push to stack. When smaller found, pop and resolve.</p>
        <p><b>Example:</b> Largest Rectangle in Histogram.</p>

        <h3>5. Auxiliary Stack for O(1) Queries:</h3>
        <p><b>Use When:</b> Need O(1) min/max while maintaining stack operations.</p>
        <p><b>Template:</b> Second stack tracks min/max at each state.</p>
        <p><b>Example:</b> Min Stack.</p>

        <p class="tag">Common Thread:</p> Stack = "most recent matters" or "waiting for future to resolve past". Monotonic stacks efficiently find next greater/smaller by maintaining sorted order.
    </div>

    <!-- Monotonic Stack Deep Dive -->
    <div class="box">
        <h2>Monotonic Stack Cheat Sheet</h2>
        <h3>When to Use:</h3>
        <p>Finding <b>next greater</b> or <b>next smaller</b> element for each position in O(n).</p>
        <h3>Mono Decreasing (Next Greater):</h3>
        <div class="code-box">// Stack top is smallest. Pop when greater found.
for i := range arr:
  for stack not empty && arr[stack.top] < arr[i]:
    // arr[i] is the "next greater" for stack.top
    pop and process
  push(i)</div>
        <h3>Mono Increasing (Next Smaller):</h3>
        <div class="code-box">// Stack top is largest. Pop when smaller found.
for i := range arr:
  for stack not empty && arr[stack.top] > arr[i]:
    // arr[i] is the "next smaller" for stack.top
    pop and process
  push(i)</div>
        <p><b>Store Indices:</b> Almost always store indices, not values. Need index to calculate distances and access original values.</p>
        <p><b>Leftover Items:</b> Elements remaining on stack have no next greater/smaller. Handle based on problem (often default to 0 or n).</p>
        <h3>The Three-Element Boundary Pattern:</h3>
        <p>For problems needing <b>both</b> left and right boundaries (rectangles, water):</p>
        <ul>
            <li><b>Current i</b> = Right boundary (triggered the violation)</li>
            <li><b>Popped element</b> = Element of interest (calculate its contribution)</li>
            <li><b>New stack top</b> = Left boundary (guaranteed by monotonic property)</li>
        </ul>
        <p><b>Why It Works:</b> Monotonic property ensures the element below the popped one is always a valid boundary - it's the nearest element in that direction satisfying the condition (smaller for increasing, larger for decreasing).</p>
    </div>

</div>

</body>
</html>
